//#指针数组：
//1.
//#include <stdio.h>
//
//int main() {
//    int a,b,c;
//
//    int * arr[3] = {&a,&b,&c}; //可以看到，实际上本质还是数组，只不过存的都是地址
//    *arr[0] = 999; //[]运算符的优先级更高，所以这里先通过[0]取出地址，然后再使用*将值赋值到对应的地址上
//    printf("%d",a);
//}
//
//
//2.
//#include <stdio.h>
//
//int main() {
//    int a=99,b=66,c=33;
//
//    int * arr[3] = {&a,&b,&c}; //可以看到，实际上本质还是数组，只不过存的都是地址
//
//    int ** pp =arr;
//    printf("%p\n",*pp); // *pp是地址
//    printf("%d\n", **pp); // **pp是地址所指的值
//    //第一个是 **pp ,则第二个是 **(pp+1)
//    printf("%d\n",**(pp+1));
//    printf("%d\n",**(pp+2));
//
//}

//#数组指针： 顾名思义，与其他指针不同，它是指向整个数组的指针 （数组指针+1可是要跳过整个数组的呀！！！）
//3.
// int * p; //指向int类型的指针
//而数组指针如下：
//int (*p)[3]; //注意此处需要将*p括起来，因为[]的优先级更高

//4.
//#include <stdio.h>
//
//int main() {
//    int arr[3]={111,222,333};
//    int (*p)[3] = &arr; /*直接对整个数组再取一次地址*/
//    printf("%d", "%d" ,"%d", *(*p+0),*(*p+1),*(*p+2)); //此处*p拿到的是数组首元素的地址
//}
/*  p代表整个数组的地址
*   *p表示所指向数组中首元素的地址
*   *p+1 表示所指向数组中第i个(0开始)元素的地址（实际上这里的*p就是指向首元素的指针）
*   *(*p + i)就是取对应地址上的值了
*/

//5.同样能解决二维数组
#include <stdio.h>

int main() {
    int arr[2][3]={{111,222,333}, {444,555,666}};
    int (*p)[3] = arr; //这个时候(二维数组)就不用取地址（&）了，因为现在维度提升，数组指针指向的是二维数组中的其中一个元素（因为元素本身
    //就是一个数组）

    //想第一个数组的第二个元素：
    printf("%d\n", *(*p+1));
    //因为上面直接指向的就是第一个数组，所以想要获取第一个元素是和之前一模一样的
    //我的理解：*p == arr; +1得到第二个元素

    //也因此，这里的p应该是整个数组里的第一个数组的地址才对

    //想要第二个数组的最后一个元素
    printf("%d\n", *(*(p+1)+2));
    /*首先*(p+1)是一个整体，表示第二个数组（因为是数组指针，所以这里一次性+1一次性跳一个数组的长度）,然后再到外层+2表示数组中的
    * 第三个元素，最后再取地址，就是第二个数组的第三个元素了
    */
    //IThink:p是数组指针，+1则跳一个数组的长度，再+2表示第三个元素，最后再取地址，就是答案了

    //甚至可以用数组表示法（苦笑）
    printf("%d\n",p[1][2]);
    //居然跟数组用法一模一样，你甚至可以认为他们一模一样
}