//1.
// #include <stdio.h>
//
// int main() {
//     char str[] ="Hello World!";
//     char * p =str;  //直接把str代表的首元素地址给到p
//     //str表示数组的首地址 ，所以完全可以将其赋值给指针变量，因为指针变量也是存放的地址
//
//     //printf("%c",*p);
//     printf("%c",p[1]); //像用数组一样用指针
// }
//
// //一个长度为3的int类型数组在内存中占据4个字节*3的空间，
// //首元素的起始地址是：0x00FAFAFA
// //（这就是为什么声明数组一定要明确类型和大小）

//2.
//#include <stdio.h>
//#include <string.h>
//
//int main() {
//    char str[] = "Hello World!";
//    char * p = str; //将首地址赋给了p
//
//    printf("%c\n",* p); //输出首地址
//    printf("%c\n",*(p+1));//此处p+1不是单纯的+1，而是根据类型长度（如char类型长度为3）移动1个长度
//
//    // for(int i = 0; i < strlen(str); i++) {
//    //     printf("%c",*p);
//    //     p++;
//    // }
//    //自己摸索了一下，确实可以这么写
//}
//
///*表示数组第二个元素时：(该操作仅对数组有意义)
// *数组表示法：'str[1]'
// *指针表示法：*(p+1)
// */


//3.
/*
 *  *p //数组的第一个元素
 *  p  //数组第一个元素的地址
 *  p == str  //肯定是真，因为都是数组首元素地址
 *  *str  //因为str就是首元素的地址，所以这里对地址加*就代表第一个元素，使用的是指针表示法
 *  &str[0]  //这里得到的实际上还是首元素的地址
 *  *(p+1)  //代表第二个元素
 *  p+1  //第二个元素的内存地址
 *  *p+1  //注意*的优先级比+要高，所以这里代表的是首元素的值+1，得到字符'K'
 */

//4.
//指针可以自加自减，而数组不行

//以上，是一维数组

/*5.
 *那么二维数组呢?
 */
//int arr[2][3]={{1,2,3},{4,5,6}};
//在内存中等效：
//int arr[6]={1,2,3,4,5,6};
//#include <stdio.h>
//int main() {
// int arr[2][3] = {{1,2,3},{4,5,6}};
// int  * p =arr[0];  //因为是二维数组，注意这里要指向第一个元素，来降一个维度才能正确给到指针
// //同理如果是arr[1]的话那么就表示二维数组中第二个数组的首元素
// printf("%d = %d", *(p + 4), arr[1][1]); //实际上这两种访问形式都是一样的
// //本质上，当一维数组看就可以了
//}